<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Enhanced Snake Game with Levels</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #000;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }

    #game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      background-color: #222;
    }

    #game-board {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: grid;
      background-color: #111;
      background-image:
        linear-gradient(#222 1px, transparent 1px),
        linear-gradient(90deg, #222 1px, transparent 1px);
    }

    .cell {
      background-color: transparent;
    }

    .snake {
      background-color: #4CAF50;
      box-shadow: 0 0 5px #4CAF50, 0 0 10px #4CAF50;
      border-radius: 2px;
    }

    .food {
      background-color: #FFC107;
      box-shadow: 0 0 5px #FFC107, 0 0 10px #FFC107;
      border-radius: 50%;
    }

    .obstacle {
      background-color: #FF5722;
      box-shadow: 0 0 5px #FF5722, 0 0 10px #FF5722;
    }

    .powerup {
      background-color: #2196F3;
      box-shadow: 0 0 5px #2196F3, 0 0 10px #2196F3;
      border-radius: 25%;
    }

    #game-over {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #FFF;
      font-size: 24px;
      text-align: center;
      display: none;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 20px;
      border-radius: 10px;
    }

    #score,
    #high-score,
    #level {
      position: absolute;
      color: #FFF;
      font-size: 18px;
    }

    #score {
      top: 10px;
      right: 10px;
    }

    #high-score {
      top: 10px;
      left: 10px;
    }

    #level {
      top: 40px;
      right: 10px;
    }

    #start-button {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: #4CAF50;
      color: white;
      border: none;
      padding: 10px 20px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 16px;
      cursor: pointer;
      border-radius: 5px;
    }
  </style>
</head>

<body>
  <div id="game-container">
    <div id="game-board"></div>
    <div id="score">Score: 0</div>
    <div id="high-score">High Score: 0</div>
    <div id="level">Level: 1</div>
    <button id="start-button">Start</button>
    <div id="game-over">
      Game Over!<br>
      Tap to restart
    </div>
  </div>

  <script>
    const gameContainer = document.getElementById('game-container');
    const gameBoard = document.getElementById('game-board');
    const gameOverScreen = document.getElementById('game-over');
    const scoreDisplay = document.getElementById('score');
    const highScoreDisplay = document.getElementById('high-score');
    const levelDisplay = document.getElementById('level');
    const startButton = document.getElementById('start-button');
    let snake = [{
      x: 10,
      y: 10
    }];
    let food = {
      x: 15,
      y: 15
    };
    let obstacles = [];
    let powerup = null;
    let direction = {
      x: 1,
      y: 0
    };
    let gameOver = false;
    let boardSize = {
      width: 20,
      height: 20
    };
    let cellSize = 20;
    let score = 0;
    let highScore = 0;
    let level = 1;
    let gameLoop;
    let gameSpeed = 150;
    let powerupActive = false;
    let powerupTimer = null;
    let touchStartX, touchStartY;
    let lastTouchTime = 0;
    const touchThreshold = 20;
    const touchCooldown = 100;

    function initGame() {
      updateBoardSize();
      createBoard();
      placeFood();
      document.addEventListener('keydown', changeDirection);
      gameContainer.addEventListener('touchstart', handleTouchStart);
      gameContainer.addEventListener('touchmove', handleTouchMove);
      gameContainer.addEventListener('touchend', handleTouchEnd);
      startButton.addEventListener('click', startGame);
      loadHighScore();
    }

    function startGame() {
      if (gameLoop) clearInterval(gameLoop);
      snake = [{
        x: 10,
        y: 10
      }];
      direction = {
        x: 1,
        y: 0
      };
      gameOver = false;
      score = 0;
      level = 1;
      gameSpeed = 150;
      obstacles = [];
      powerup = null;
      powerupActive = false;
      if (powerupTimer) clearTimeout(powerupTimer);
      updateScore();
      updateLevel();
      gameOverScreen.style.display = 'none';
      startButton.style.display = 'none';
      placeFood();
      placeObstacles();
      gameLoop = setInterval(gameTick, gameSpeed);
    }

    function updateBoardSize() {
      const containerWidth = gameContainer.clientWidth;
      const containerHeight = gameContainer.clientHeight;
      cellSize = Math.floor(Math.min(containerWidth, containerHeight) / 20);
      boardSize.width = 20;
      boardSize.height = 20;
      gameBoard.style.width = `${boardSize.width * cellSize}px`;
      gameBoard.style.height = `${boardSize.height * cellSize}px`;
      gameBoard.style.gridTemplateColumns = `repeat(${boardSize.width}, ${cellSize}px)`;
      gameBoard.style.gridTemplateRows = `repeat(${boardSize.height}, ${cellSize}px)`;
      gameBoard.style.backgroundSize = `${cellSize}px ${cellSize}px`;
    }

    function createBoard() {
      gameBoard.innerHTML = '';
      for (let i = 0; i < boardSize.height * boardSize.width; i++) {
        const cell = document.createElement('div');
        cell.classList.add('cell');
        gameBoard.appendChild(cell);
      }
    }

    function placeFood() {
      do {
        food = {
          x: Math.floor(Math.random() * boardSize.width),
          y: Math.floor(Math.random() * boardSize.height)
        };
      } while (
        snake.some(segment => segment.x === food.x && segment.y === food.y) ||
        obstacles.some(obstacle => obstacle.x === food.x && obstacle.y === food.y)
      );
    }

    function placePowerup() {
      if (Math.random() < 0.1 && !powerup) {
        do {
          powerup = {
            x: Math.floor(Math.random() * boardSize.width),
            y: Math.floor(Math.random() * boardSize.height)
          };
        } while (
          snake.some(segment => segment.x === powerup.x && segment.y === powerup.y) ||
          obstacles.some(obstacle => obstacle.x === powerup.x && obstacle.y === powerup.y) ||
          (food.x === powerup.x && food.y === powerup.y)
        );
      }
    }

    function placeObstacles() {
      obstacles = [];
      const numObstacles = Math.min(5 + level, 15);
      for (let i = 0; i < numObstacles; i++) {
        let obstacle;
        do {
          obstacle = {
            x: Math.floor(Math.random() * boardSize.width),
            y: Math.floor(Math.random() * boardSize.height)
          };
        } while (
          snake.some(segment => segment.x === obstacle.x && segment.y === obstacle.y) ||
          (food.x === obstacle.x && food.y === obstacle.y) ||
          obstacles.some(existingObstacle => existingObstacle.x === obstacle.x && existingObstacle.y === obstacle.y)
        );
        obstacles.push(obstacle);
      }
    }

    function gameTick() {
      moveSnake();
      if (!gameOver) {
        updateBoard();
      }
    }

    function moveSnake() {
      const head = {
        x: snake[0].x + direction.x,
        y: snake[0].y + direction.y
      };
      head.x = (head.x + boardSize.width) % boardSize.width;
      head.y = (head.y + boardSize.height) % boardSize.height;
      if (
        snake.some(segment => segment.x === head.x && segment.y === head.y) ||
        (!powerupActive && obstacles.some(obstacle => obstacle.x === head.x && obstacle.y === head.y))
      ) {
        gameOver = true;
        gameOverScreen.style.display = 'block';
        startButton.style.display = 'block';
        clearInterval(gameLoop);
        updateHighScore();
        return;
      }
      snake.unshift(head);
      if (head.x === food.x && head.y === food.y) {
        score += 10;
        updateScore();
        placeFood();
        placePowerup();
        if (snake.length % 5 === 0) {
          levelUp();
        }
      } else if (powerup && head.x === powerup.x && head.y === powerup.y) {
        activatePowerup();
      } else {
        snake.pop();
      }
    }

    function updateBoard() {
      const cells = document.getElementsByClassName('cell');
      for (let i = 0; i < cells.length; i++) {
        cells[i].classList.remove('snake', 'food', 'obstacle', 'powerup');
      }
      snake.forEach(segment => {
        const index = segment.y * boardSize.width + segment.x;
        cells[index].classList.add('snake');
      });
      const foodIndex = food.y * boardSize.width + food.x;
      cells[foodIndex].classList.add('food');
      obstacles.forEach(obstacle => {
        const index = obstacle.y * boardSize.width + obstacle.x;
        cells[index].classList.add('obstacle');
      });
      if (powerup) {
        const powerupIndex = powerup.y * boardSize.width + powerup.x;
        cells[powerupIndex].classList.add('powerup');
      }
    }

    function updateScore() {
      scoreDisplay.textContent = `Score: ${score}`;
    }

    function updateHighScore() {
      if (score > highScore) {
        highScore = score;
        highScoreDisplay.textContent = `High Score: ${highScore}`;
        localStorage.setItem('snakeHighScore', highScore);
      }
    }

    function loadHighScore() {
      const savedHighScore = localStorage.getItem('snakeHighScore');
      if (savedHighScore) {
        highScore = parseInt(savedHighScore);
        highScoreDisplay.textContent = `High Score: ${highScore}`;
      }
    }

    function updateLevel() {
      levelDisplay.textContent = `Level: ${level}`;
    }

    function levelUp() {
      level++;
      updateLevel();
      gameSpeed = Math.max(50, gameSpeed - 10);
      clearInterval(gameLoop);
      gameLoop = setInterval(gameTick, gameSpeed);
      placeObstacles();
    }

    function activatePowerup() {
      powerupActive = true;
      powerup = null;
      score += 50;
      updateScore();
      // Visual feedback for powerup activation
      gameBoard.style.boxShadow = '0 0 20px #2196F3';
      if (powerupTimer) clearTimeout(powerupTimer);
      powerupTimer = setTimeout(() => {
        powerupActive = false;
        gameBoard.style.boxShadow = 'none';
      }, 5000);
    }

    function changeDirection(event) {
      let newDirection = {
        ...direction
      };
      switch (event.key) {
        case 'ArrowUp':
          if (direction.y === 0) newDirection = {
            x: 0,
            y: -1
          };
          break;
        case 'ArrowDown':
          if (direction.y === 0) newDirection = {
            x: 0,
            y: 1
          };
          break;
        case 'ArrowLeft':
          if (direction.x === 0) newDirection = {
            x: -1,
            y: 0
          };
          break;
        case 'ArrowRight':
          if (direction.x === 0) newDirection = {
            x: 1,
            y: 0
          };
          break;
      }
      if (newDirection.x !== -direction.x || newDirection.y !== -direction.y) {
        direction = newDirection;
      }
    }

    function handleTouchStart(event) {
      touchStartX = event.touches[0].clientX;
      touchStartY = event.touches[0].clientY;
    }

    function handleTouchMove(event) {
      if (!touchStartX || !touchStartY) {
        return;
      }
      const currentTime = new Date().getTime();
      if (currentTime - lastTouchTime < touchCooldown) {
        return;
      }
      const touchEndX = event.touches[0].clientX;
      const touchEndY = event.touches[0].clientY;
      const deltaX = touchEndX - touchStartX;
      const deltaY = touchEndY - touchStartY;
      if (Math.abs(deltaX) > touchThreshold || Math.abs(deltaY) > touchThreshold) {
        let newDirection = {
          ...direction
        };
        if (Math.abs(deltaX) > Math.abs(deltaY)) {
          newDirection = deltaX > 0 ? {
            x: 1,
            y: 0
          } : {
            x: -1,
            y: 0
          };
        } else {
          newDirection = deltaY > 0 ? {
            x: 0,
            y: 1
          } : {
            x: 0,
            y: -1
          };
        }
        if (newDirection.x !== -direction.x || newDirection.y !== -direction.y) {
          direction = newDirection;
          lastTouchTime = currentTime;
        }
        touchStartX = touchEndX;
        touchStartY = touchEndY;
      }
    }

    function handleTouchEnd() {
      touchStartX = null;
      touchStartY = null;
    }
    window.addEventListener('resize', () => {
      updateBoardSize();
      createBoard();
      updateBoard();
    });
    gameContainer.addEventListener('click', () => {
      if (gameOver) startGame();
    });
    initGame();
  </script>

</body>

</html>